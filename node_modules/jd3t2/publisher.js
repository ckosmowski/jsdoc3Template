var TAFFY = require('taffydb').taffy,
	fs = require('fs'),
	path = require('path'),
	CLIArgs = require('CLIArgs'),
	Links = require('./publish/Links')
;

CLIArgs.add('in_path', 'Path to the sources', true);
CLIArgs.bind('i', 'in_path');
CLIArgs.add('out_path', 'Path where this process put the generated documentation, ATTENTION: must be cleaned!', true);
CLIArgs.bind('O', 'out_path');
CLIArgs.add('tmp_path', 'Path to put temporal files', true, process.cwd() + '/tmp');

CLIArgs.add('tutorial_path', 'Path to the tutorial files (EXPERIMENTAL)', true);
CLIArgs.bind('T', 'tutorial_path');

CLIArgs.add('notIncludeSources', 'The source html representations, and the references to where is defined the elements not will generated');
CLIArgs.add('private', 'Private elements will be added to documentation (EXPERIMENTAL)');
CLIArgs.add('child', 'Identifies that this is a child process');

var Publisher = {

	input: null,
	output: null,
	tmp: null,
	tutorials: null,
	opts: {
		includeSources: true,
		privates: false
	},
	db: null,
	dbReferences: null,

	init: function(opts){
		if(undefined === opts){
			CLIArgs.process();
			opts = {
				in_path: CLIArgs.has('in_path'),
				out_path: CLIArgs.has('out_path'),
				tmp_path: CLIArgs.has('tmp_path'),
				tutorial_path: CLIArgs.has('tutorial_path'),
				includeSources: !CLIArgs.has('notIncludeSources'),
				privates: !!CLIArgs.has('private')
			};
		}

		this._initProps(opts);
		this.db = TAFFY();

		this._cleanOutput();
	},

	_initProps: function(opts){
		this.log = CLIArgs.has('child') ? this.log_process : this.log_console;

		this.input = path.normalize( opts.in_path );

		if(!fs.existsSync(this.input)){
			var msg = 'Can\'t access to sources path: ' + this.input;
			this.log('error', msg);
			throw msg;
		}

		this.output = path.normalize( opts.out_path );
		this.tmp = path.normalize( opts.tmp_path );

		this._createPathIfNotExists(this.output);
		this._createPathIfNotExists(this.tmp);

		this.tutorials = path.normalize( opts.tutorial_path );
		if(opts.tutorial_path !== false && !fs.existsSync(this.tutorials)){
			this.log('warning', 'Tutorial path not found ' + this.tutorials);
		}

		this.opts.includeSources = opts.includeSources;
		this.opts.privates = opts.privates;
	},

	_createPathIfNotExists: function(path){
		if(!fs.existsSync(path)){
			if(!fs.mkdirSync(path, 0777)){
				var msg = 'Can\'t create or access to path: ' + path;
				this.log('error', msg);
				throw msg;
			}
		}
	},

	_cleanOutput: function(){
		this.log('debug', 'Cleaning ' + this.output);
		this._deleteInnerDir(this.output);

		fs.mkdirSync(this.output + '/statics');
		fs.mkdirSync(this.output + '/files');
		fs.mkdirSync(this.output + '/classes');
		fs.mkdirSync(this.output + '/namespaces');
		fs.mkdirSync(this.output + '/others');
	},

	_deleteInnerDir: function(path) {
		var files = [], me = this;
		if( fs.existsSync(path) ) {
			files = fs.readdirSync(path);
			files.forEach(function(file,index){
				var curPath = path + "/" + file;
				if(fs.statSync(curPath).isDirectory()) { // recurse
					me._deleteInnerDir(curPath);
					fs.rmdirSync(curPath);
				} else { // delete file
					fs.unlinkSync(curPath);
				}
			});
		}
	},

	process: function(JSONData){
		var i;

		this._initProcessProps();

		for( i = 0; i < JSONData.length ; i++){
			this.db.insert(JSONData[i]);
		}

		this.sanitize.process();
		
		console.log( this.db().get() );


	},

	_initProcessProps: function(){
		this.links = new Links(this);
		this.sanitize = new SanitizeDoclets(this);
	},


	log: function(level, msg){

	},
	log_process: function(level, msg){
		process.send('log', {level: level, msg: msg});
	},

	log_console: function(level, msg){
		console.log('[' + level + '] ' + msg);
	}


};

module.exports = Publisher;

